#ifndef ROTATE_NXC
#define ROTATE_NXC

#include "constant.h"

#define ROTATE_DEFAULT_POWER    30                  // Default power of the rotation
#define MIN_ROTATION_ANGLE      3                   // Minimum accepted angle

#define ROTATE_RECTIF_COEFF     0.5
#define SLOPE_POWER_SPEED       2.933               //  These values are chosen so that a power of 10 correspond to a anglular speed of 10°/s
#define ORD_POWER_SPEED         19.333              //  and a power of 100 correspond to an angular speed of 274°/s (which should be the maximum for the motors)
#define CONST 2.05556                               // Coeff tacho/angle_robot

//#define CALIB                                     // Used to calibrate the constant

// counterclockwise rotate jarvis of angle (in °) at a speed defined by power (between 10 and 90 should be good)
void rotateLeft(float angle, int power=ROTATE_DEFAULT_POWER) {

    // Compute the final value of the tachos
    const long l_tacho_start = MotorRotationCount(OUT_A);
    const long r_tacho_start = MotorRotationCount(OUT_B);
    const long l_tacho_end = l_tacho_start - angle*CONST;
    const long r_tacho_end = r_tacho_start + angle*CONST;
    long l_tacho = 0;
    long r_tacho = 0;

    // Initial situation
    const float angle_start = current_pos.theta;
    long tick_start = CurrentTick();
    long tickPause = 0;

    // used as a feedback over the rotation of each motor
    float coeff, speed_rectif;

    // speed  (in °/s) associated to the given power (Cf definition of the constants)
    const int speed_degree = SLOPE_POWER_SPEED*power - ORD_POWER_SPEED;

    // Set the ROTATING flag
    ROTATING = true;

    OnRev(OUT_A, power);
    OnFwd(OUT_B, power);
    #ifdef CALIB
    until(touch) {
    #else
    while((l_tacho_end-l_tacho_start < l_tacho || r_tacho_end-r_tacho_start > r_tacho) && !STOP) {
    #endif
        if(PAUSE) {
            // Save the current time when the function is paused
            if(tickPause == 0) {
                Off(OUT_AB);
                tickPause = CurrentTick();
                Release(movement_mutex);
            }

            Wait(100);
            continue;
        }
        else
            // Ajust the current time depending on the time spent in pause
            if(tickPause != 0) {
                tick_start += CurrentTick()-tickPause;
                tickPause = 0;
                Acquire(movement_mutex);
            }

        // Get the tachos
        l_tacho = MotorRotationCount(OUT_A)-l_tacho_start;
        r_tacho = MotorRotationCount(OUT_B)-r_tacho_start;

        // Update the orientation of jarvis
        current_pos.theta = (angle_start + r_tacho/CONST);
        current_pos.theta = current_pos.theta % 360;

        // coeff used to ensure both wheels are synchronized
        coeff = (l_tacho + r_tacho)*ROTATE_RECTIF_COEFF;

        // coeff used to ensure that the average speed is close to the theoritical value (given with power)
        if(r_tacho == 0)
            speed_rectif = 1;
        else
            // quotient of the average speed until now over the theoritical speed
            speed_rectif = ((CurrentTick()-tick_start)*speed_degree*CONST)/(1000*r_tacho);
        if(speed_rectif == 0 || speed_rectif < 0) speed_rectif = 1;
        if(speed_rectif > 100/power) speed_rectif = 100/power;

        // Modify the power of the motors accordingly
        OnRev(OUT_A, speed_rectif*power+coeff);
        OnFwd(OUT_B, speed_rectif*power-coeff);
    }
    Off(OUT_AB);

    // Notify the termination of the rotation
    STOP = false;

    // Set the ROTATING flag
    ROTATING = false;

    #ifdef CALIB
    for(;;);
    #endif
}

// clockwise rotate jarvis of angle (in °) at a speed defined by power (between 10 and 90 should be good)
// See rotateLeft for details about the internal behaviour of the function
void rotateRight(float angle, int power=ROTATE_DEFAULT_POWER) {
    const long l_tacho_start = MotorRotationCount(OUT_A);
    const long r_tacho_start = MotorRotationCount(OUT_B);
    const long l_tacho_end = l_tacho_start + angle*CONST;
    const long r_tacho_end = r_tacho_start - angle*CONST;
    long l_tacho = 0;
    long r_tacho = 0;
    const float angle_start = current_pos.theta;
    long tick_start = CurrentTick();
    long tickPause = 0;
    float coeff, speed_rectif;
    const int speed_degree = SLOPE_POWER_SPEED*power - ORD_POWER_SPEED;
    ROTATING = true;
    OnFwd(OUT_A, power);
    OnRev(OUT_B, power);
    #ifdef CALIB
    until(touch) {
    #else
    while((l_tacho_end-l_tacho_start > l_tacho || r_tacho_end-r_tacho_start < r_tacho) && !STOP) {
    #endif
        if(PAUSE) {
            if(tickPause == 0) {
                Off(OUT_AB);
                tickPause = CurrentTick();
                Release(movement_mutex);
            }
            Wait(100);
            continue;
        }
        else
            if(tickPause != 0) {
                tick_start += CurrentTick()-tickPause;
                tickPause = 0;
                Acquire(movement_mutex);
            }
        l_tacho = MotorRotationCount(OUT_A)-l_tacho_start;
        r_tacho = MotorRotationCount(OUT_B)-r_tacho_start;
        current_pos.theta = (angle_start - l_tacho/CONST);
        current_pos.theta = current_pos.theta % 360;
        coeff = (l_tacho + r_tacho)*ROTATE_RECTIF_COEFF;
        if(l_tacho == 0)
            speed_rectif = 1;
        else
            speed_rectif = ((CurrentTick()-tick_start)*speed_degree*CONST)/(1000*l_tacho);
        if(speed_rectif == 0 || speed_rectif < 0) speed_rectif = 1;
        if(speed_rectif > 100/power) speed_rectif = 100/power;
        OnFwd(OUT_A, speed_rectif*power-coeff);
        OnRev(OUT_B, speed_rectif*power+coeff);
    }
    Off(OUT_AB);
    STOP = false;
    ROTATING = false;
    #ifdef CALIB
    for(;;);
    #endif
}

// rotate jarvis of angle (positive is for counterclockwise) at the speed defined by power
void rotate(float angle, int power=ROTATE_DEFAULT_POWER) {
    // Ignore the command if the angle is too small
    if(abs(angle) < MIN_ROTATION_ANGLE)
        return;

    Acquire(movement_mutex);
    if(angle > 0)
        rotateLeft(angle, power);
    else
        rotateRight(-angle, power);
    Release(movement_mutex);
}

// rotate jarvis to specifed angle at the speed defined by power
void setTheta(float angle, int power=ROTATE_DEFAULT_POWER) {
    float turn_angle = angle-current_pos.theta;
    turn_angle = turn_angle % 360;
    if(turn_angle < 0) turn_angle += 360;
    if(turn_angle < 180)
        rotateLeft(turn_angle, power);
    else
        rotateRight(360-turn_angle, power);
}

#endif      // rotate.nxc
